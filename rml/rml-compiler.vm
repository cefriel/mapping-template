## This template reuses and adapts the "mapping query" from the SDM-RDFizer source code (https://github.com/SDM-TIB/SDM-RDFizer) developed by the Scientific Data Management Group at TIB.
## The query is modified to be compliant with the latest RML specification (https://w3id.org/rml).

#set ( $prefixes = $reader.setPrefixes("
    prefix rml: <http://w3id.org/rml/>
    prefix dcat: <http://www.w3.org/ns/dcat#>
    prefix d2rq: <http://www.wiwiss.fu-berlin.de/suhl/bizer/D2RQ/0.1#>
") )

#set($d="$") 
#set($h="#") 
#set($pa="{") 
#set($pc="}")
#set($defaultNamespace = "http://www.cefriel.com/kt/")

#set ( $mappings_content = $reader.getDataframe("
SELECT DISTINCT *
WHERE {

	# Subject -------------------------------------------------------------------------
			?triples_map_id rml:logicalSource ?_source .
			OPTIONAL{?_source rml:source ?data_source .}
			OPTIONAL{
                ?data_source a dcat:Distribution .
				?data_source dcat:accessURL ?access_url . # downloadURL would be better
			}
            # TODO Handle relative paths
            OPTIONAL{
                ?data_source a rml:RelativePathSource .
                ?data_source rml:root ?root_folder .
				?data_source rml:path ?path .
			}
			OPTIONAL {?_source rml:referenceFormulation ?ref_form .} # missing in BC page
			OPTIONAL { ?_source rml:iterator ?iterator . }
			OPTIONAL { ?_source rml:query ?query .}
            # TODO Handle rml:null

			?triples_map_id rml:subjectMap ?_subject_map .
			OPTIONAL {?_subject_map rml:template ?subject_template .}
			OPTIONAL {?_subject_map rml:reference ?subject_reference .}
			OPTIONAL {?_subject_map rml:constant ?subject_constant}
            OPTIONAL {?triples_map_id rml:subject ?subject_constant_shortcut .}

			OPTIONAL { ?_subject_map rml:termType ?subject_termtype . }

			OPTIONAL { ?_subject_map rml:graph ?graph_constant_shortcut . }
			OPTIONAL { ?_subject_map rml:graphMap ?_graph_structure .
					   ?_graph_structure rml:constant ?graph_constant . }
            OPTIONAL { ?_subject_map rml:graphMap ?_graph_structure .
					    ?_graph_structure rml:reference ?graph_reference . }
			OPTIONAL { ?_subject_map rml:graphMap ?_graph_structure .
					   ?_graph_structure rml:template ?graph_template . }		   

	# Predicate -----------------------------------------------------------------------
			OPTIONAL {
			?triples_map_id rml:predicateObjectMap ?_predicate_object_map .

			OPTIONAL {
				?_predicate_object_map rml:predicateMap ?_predicate_map .
				?_predicate_map rml:constant ?predicate_constant .
			}
			OPTIONAL {
				?_predicate_object_map rml:predicateMap ?_predicate_map .
				?_predicate_map rml:template ?predicate_template .
			}
			OPTIONAL {
				?_predicate_object_map rml:predicateMap ?_predicate_map .
				?_predicate_map rml:reference ?predicate_reference .
			}
			OPTIONAL {
				?_predicate_object_map rml:predicate ?predicate_constant_shortcut .
			}

	# Object --------------------------------------------------------------------------
			OPTIONAL {
				?_predicate_object_map rml:objectMap ?_object_map .
				?_object_map rml:constant ?object_constant .
			}
			OPTIONAL {
				?_predicate_object_map rml:objectMap ?_object_map .
				?_object_map rml:template ?object_template .
			}
			OPTIONAL {
				?_predicate_object_map rml:objectMap ?_object_map .
				?_object_map rml:reference ?object_reference .
			}
            OPTIONAL {
                ?_predicate_object_map rml:objectMap ?_object_map .
                ?_object_map rml:languageMap ?_language_map .
                ?_language_map rml:constant ?language_constant .
            }
            OPTIONAL {
                ?_predicate_object_map rml:objectMap ?_object_map .
                ?_object_map rml:languageMap ?_language_map .
                ?_language_map rml:template ?language_template .
            }
            OPTIONAL {
                ?_predicate_object_map rml:objectMap ?_object_map .
                ?_object_map rml:languageMap ?_language_map .
                ?_language_map rml:reference ?language_reference .
            }
            OPTIONAL {
                ?_predicate_object_map rml:objectMap ?_object_map .
                ?_object_map rml:language ?language_constant_shortcut .
            }
            OPTIONAL {
                ?_predicate_object_map rml:objectMap ?_object_map .
                ?_object_map rml:datatypeMap ?_datatype_map .
                ?_datatype_map rml:constant ?datatype_constant .
            }
            OPTIONAL {
                ?_predicate_object_map rml:objectMap ?_object_map .
                ?_object_map rml:datatypeMap ?_datatype_map .
                ?_datatype_map rml:template ?datatype_template .
            }
            OPTIONAL {
                ?_predicate_object_map rml:objectMap ?_object_map .
                ?_object_map rml:datatypeMap ?_datatype_map .
                ?_datatype_map rml:reference ?datatype_reference .
            }
            OPTIONAL {
                ?_predicate_object_map rml:objectMap ?_object_map .
                ?_object_map rml:datatype ?datatype_constant_shortcut .
            }
			OPTIONAL {
				?_predicate_object_map rml:objectMap ?_object_map .
				?_object_map rml:parentTriplesMap ?object_parent_triples_map .
				OPTIONAL {
					?_object_map rml:joinCondition ?join_condition .
					?join_condition rml:child ?child_value;
								 rml:parent ?parent_value.
					OPTIONAL {?_object_map rml:termType ?term .}
				}
			}
			OPTIONAL {
				?_predicate_object_map rml:object ?object_constant_shortcut .
			}
			OPTIONAL {?_predicate_object_map rml:graph ?predicate_object_graph .}
			OPTIONAL { ?_predicate_object_map  rml:graphMap ?_graph_structure .
					   ?_graph_structure rml:constant ?predicate_object_graph  . }
			OPTIONAL { ?_predicate_object_map  rml:graphMap ?_graph_structure .
					   ?_graph_structure rml:template ?predicate_object_graph  . }	
			}
			OPTIONAL {
				?data_source a d2rq:Database;
  				d2rq:jdbcDSN ?jdbcDSN; 
  				d2rq:jdbcDriver ?jdbcDriver; 
			    d2rq:username ?user;
			    d2rq:password ?password .
			}
		} 
") )

#* Needed because there can be more than one class *#
#set ( $subjectClassesQuery = "
    SELECT DISTINCT *
    WHERE {
        <TRIPLES_MAP> rml:subjectMap ?_subject_map .
        ?_subject_map rml:class ?subject_rdf_class . 
    }
")

#* 
Get map ordered by TriplesMap, only one row is kept for each triples_map_id
to access commond information (e.g., logical source) and add additional 
useful information (e.g., sourceHash)
*#
#set($lTriplesMaps = $functions.getMap($mappings_content, "triples_map_id"))

#foreach($tm in $lTriplesMaps.keySet())
    #set($refs = [])
    #set($foo = $lTriplesMaps.get($tm).put("_REFS_", $refs))
#end

#* Get all references for each row extracted *#
#foreach($row in $mappings_content)

    #set($lReferences = [])

    #* SUBJECT *#
    #if($row.subject_template)
        #set($foo = $lReferences.addAll($functions.getReferencesFromTemplate($row.subject_template)))
    #elseif($row.subject_reference)
        #set($foo = $lReferences.add($row.subject_reference))
    #end

    #* GRAPH *#
    #if($row.graph_template)
        #set($foo = $lReferences.addAll($functions.getReferencesFromTemplate($row.graph_template)))
    #elseif($row.graph_reference)
        #set($foo = $lReferences.add($row.graph_reference))
    #end

    #* PREDICATE *#
    #if($row.predicate_template)
        #set($foo = $lReferences.addAll($functions.getReferencesFromTemplate($row.predicate_template)))
    #elseif($row.predicate_reference)
        #set($foo = $lReferences.add($row.predicate_reference))
    #end

    #* OBJECT *#
    #if($row.object_template)
        #set($foo = $lReferences.addAll($functions.getReferencesFromTemplate($row.object_template)))
    #elseif($row.object_reference)
        #set($foo = $lReferences.add($row.object_reference))
    #* JOIN *#
    #elseif($row.object_parent_triples_map)
        #if($row.child_value)
            #set($foo = $lReferences.add($row.child_value))
        #end
        #if($row.parent_value)
            #set($parentTriplesMap = $row.object_parent_triples_map)
            #set($foo = $lTriplesMaps.get($row.parentTriplesMap).get("_REFS_").add($row.parent_value))
        #end
    #end

    #* LANGUAGE *#
    #if($row.language_template)
        #set($foo = $lReferences.addAll($functions.getReferencesFromTemplate($row.language_template)))
    #elseif($row.language_reference)
        #set($foo = $lReferences.add($row.language_reference))
    #end

    #* DATATYPE *#
    #if($row.datatype_template)
        #set($foo = $lReferences.addAll($functions.getReferencesFromTemplate($row.datatype_template)))
    #elseif($row.datatype_reference)
        #set($foo = $lReferences.add($row.datatype_reference))
    #end

    #* Add ALL extracted REFERENCES *#
    #set($foo = $lTriplesMaps.get($row.triples_map_id).get("_REFS_").addAll($lReferences))
#end

#* Get only distinct REFS for each TriplesMap *#
#foreach($tm in $lTriplesMaps.keySet())
    #set($refs = $lTriplesMaps.get($tm).get("_REFS_"))
    #set($foo = $lTriplesMaps.get($tm).put("_REFS_", $functions.getDistinct($refs)))
#end

#* Get only distinct REFS for each Logical Source *#
#set($lLogicalSources = $functions.getMap($mappings_content, "_source"))
#foreach($ls in $lLogicalSources.keySet())
    #if(!$lLogicalSources.get($ls).get("_REFS_"))
        #set($refs = [])
        #set($foo = $lLogicalSources.get($ls).put("_REFS_", $refs))
    #end
#end
#foreach($tm in $lTriplesMaps.keySet())
    #set($refs = $lTriplesMaps.get($tm).get("_REFS_"))
    #set($foo = $lLogicalSources.get($tm._source).get("_REFS_").addAll($refs))
#end
#foreach($ls in $lLogicalSources.keySet())
    #set($refs = $lLogicalSources.get($ls).get("_REFS_"))
    #set($foo = $lLogicalSources.get($ls).put("_REFS_", $functions.getDistinct($refs)))
#end

#* 
    TODO Check if can be optimized to get a single dataframe also for different
    logical sources accessing the same "input" 
*#
#foreach($lsEntry in $lLogicalSources.entrySet())
    #set($ls = $lsEntry.value)

    #if($ls.access_url)
        #set($sourceUrl = $functions.replace($ls.access_url, "file://", ""))
    #elseif($ls.path)
        #set($sourceUrl = "/data/shared/" + $ls.path)
    #end

    #set($refForm = $ls.ref_form)
    #set($sourceHash = $functions.hash($ls._source))
    #set($foo = $ls.put("_SOURCE_HASH_", $sourceHash))

    #* Get References for the source *#
    #set($lsReferences = $ls.get("_REFS_"))

    #* ITERATOR *#
    #set($iterator = $ls.iterator)

    #* Default value to false *#
    #set($foo = $ls.put("_HASH_VARIABLE_", false))

    #if($refForm == "http://w3id.org/rml/CSV")
        ${h}set(${d}reader_$sourceHash = ${d}functions.getCSVReaderFromFile("$sourceUrl"))
        ${h}set(${d}columns = "$functions.getAsCommaSeparatedString($lsReferences)")
        ${h}set(${d}dataframe_$sourceHash = ${d}reader_${sourceHash}.getDataframe(${d}columns))
    #elseif($refForm == "http://w3id.org/rml/SQL2008Table" || $refForm == "http://w3id.org/rml/SQL2008Query")
        ${h}set(${d}reader_$sourceHash = ${d}functions.getSQLReaderFromDatabase("$ls.jdbcDSN", "$ls.user", "$ls.password"))
        #* TODO Check with RML-io *#
        #if($ls.query)
            #set($iterator = $ls.query)
        #end
        #* Postgres keeps table name lowercase, cf. Issue #123 rml-core *#
        #if($refForm == "http://w3id.org/rml/SQL2008Table" && $ls.jdbcDSN.contains("postgres"))
            #set($iterator = $iterator.toLowerCase())
        #end
        ${h}set(${d}dataframe_$sourceHash = ${d}reader_${sourceHash}.getDataframe("$iterator"))
        ${h}set(${d}types_$sourceHash = ${d}reader_${sourceHash}.getColumnTypes("$iterator"))
        ${h}set(${d}columns = $functions.getAsStringArray($lsReferences))
        ${h}foreach(${d}column in ${d}types_${sourceHash}.keySet())
            ${h}if(!${d}columns.contains(${d}column))
                ${d}error: "${d}column not found in ${d}dataframe_$sourceHash." 
            ${h}end
        ${h}end
        #set($sqlTypes = true)
    #elseif ($refForm == "http://w3id.org/rml/XPath")
        ${h}set(${d}reader_$sourceHash = ${d}functions.getXMLReaderFromFile("$sourceUrl"))
        #set($foo = $ls.put("_HASH_VARIABLE_", true))

        #* 
            Access the XML input to extract the dataframe considering references 
            in the triplemaps associated with the same logical source 
        *#
        #if($functions.checkList($lsReferences))
            #set($xmlQuery = '
                for $i in ITERATOR
                return map {
            ')
            #set($xmlQuery = $xmlQuery.replace("ITERATOR", $iterator))
            #foreach($ref in $lsReferences) 
                #set($refHash = $functions.hash($ref))
                #* Check if text() should be added *#
                #set ($parts = $ref.split("/"))
                #if(!$parts.get($parts.size() - 1).contains("@"))
                    #set($ref = "${ref}/text()")
                #end
                #set($referenceQuery = '"VARIABLE": $i/REFERENCE,
                ')
                #set($referenceQuery = $referenceQuery.replace("VARIABLE", $refHash))
                #set($referenceQuery = $referenceQuery.replace("REFERENCE", $ref))
                #set($xmlQuery = "${xmlQuery}${referenceQuery}")
            #end
            #* Remove last comma *#
            #set($xmlQuery = $xmlQuery.trim())
            #set($xmlQuery = $xmlQuery.substring(0, $xmlQuery.length() - 1))
            #set($xmlQuery = "${xmlQuery} }")

            ${h}set(${d}dataframe_$sourceHash = ${d}reader_${sourceHash}.getDataframe('$xmlQuery'))
        #else
            #* CONSTANT values, iterate once *#
            ${h}set(${d}dataframe_$sourceHash = {"ITERATOR" : "ONCE"})
        #end

    #elseif ($refForm=="http://w3id.org/rml/JSONPath")
        ${h}set(${d}reader_$sourceHash = ${d}functions.getJSONReaderFromFile("$sourceUrl"))
        #set($foo = $ls.put("_HASH_VARIABLE_", true))

        #* 
            Access the JSON input to extract the dataframe considering references 
            in the triplemaps associated with the same logical source 
        *#
        #if($functions.checkList($lsReferences))
            #set($jsonQuery = '{
                "iterator": "ITERATOR_PATH",
                "paths": {
            ')
            #set($jsonQuery = $jsonQuery.replace("ITERATOR_PATH", $iterator))
            #foreach($ref in $lsReferences) 
                #set($refHash = $functions.hash($ref))
                #set($referenceQuery = '"VARIABLE": "REFERENCE",
                ')
                #set($referenceQuery = $referenceQuery.replace("VARIABLE", $refHash))
                #set($referenceQuery = $referenceQuery.replace("REFERENCE", $ref))
                #set($jsonQuery = "${jsonQuery}${referenceQuery}")
            #end
            #* Remove last comma *#
            #set($jsonQuery = $jsonQuery.trim())
            #set($jsonQuery = $jsonQuery.substring(0, $jsonQuery.length() - 1))
            #set($jsonQuery = "${jsonQuery} }}")

            ${h}set(${d}dataframe_$sourceHash = ${d}reader_${sourceHash}.getDataframe('$jsonQuery'))
        #else
            #* CONSTANT values, iterate once *#
            ${h}set(${d}dataframe_$sourceHash = {"ITERATOR" : "ONCE"})
        #end
    #else
        ${d}error: "No compatible Reader found." 
    #end
#end

#* ########## GENERATE DATAFRAMES FOR JOINS ########## *#
#foreach($row in $mappings_content)
    #set($sourceHash = $functions.hash($row._source))

    #if($row.object_parent_triples_map)
        #set($tmParent = $lTriplesMaps.get($row.object_parent_triples_map))

        #set($join_hash = $functions.appendHash($row.triples_map_id, $row.object_parent_triples_map, $row.child_value, $row.parent_value))
        
        #set($child_df = "$dataframe_" + $sourceHash)
        #set($parentHash = $functions.hash($tmParent._source))
        #set($parent_df = "$dataframe_" + $parentHash)
        
        ${h}if(!${d}dataframe_join_$join_hash)
            #if($row.join_condition)
                #set($join_variable = $row.parent_value)
                #if($hashVariable)
                    #set($join_variable = $functions.hash($row.parent_value))
                #end
                ${h}set(${d}dataframe_join_$join_hash = ${d}functions.getListMap($parent_df, "$join_variable"))
            #else
                ${h}set(${d}dataframe_join_$join_hash = $parent_df)
            #end
        ${h}end  
    #end
#end

#* ########## MACRO SUBJECT ########## *#

#macro(subjectRender $stm $hv)
    #set($subject = $null)
    #* TODO Check if default namespace should be added *#
    #if($stm.subject_template)
        #set($subject = $functions.resolveTemplate($stm.subject_template))
    #elseif($stm.subject_reference)
        #set($subject = $functions.resolveReference($stm.subject_reference))
    #elseif($stm.subject_constant)
        #set($subject = $stm.subject_constant)
    #elseif($stm.subject_constant_shortcut)
        #set($subject = $stm.subject_constant_shortcut)
    #end

    #set($subject = $functions.encodeReferencesIRI($subject, $hashVariable))

    #if ($tm.subject_termtype == "http://w3id.org/rml/BlankNode")
        #set($subject = "_:" + $subject)
    #elseif ($tm.subject_termtype == "http://w3id.org/rml/Literal")
        ${d}error: subject can not be of type Literal.
    #else
        #set($subject = '<' + $subject + '>')
    #end

    $subject
#end

#* ########## GENERATE TRIPLES ########## *#

#* Get map of lists ordered by Logical Source *#
#set($lmSources = $functions.getListMap($mappings_content, "_source"))

#foreach($lmSource in $lmSources.entrySet())
    #set($ls = $lLogicalSources.get($lmSource.key))
    #set($sourceHash = $functions.hash($ls._source))
    #set($hashVariable = $ls.get("_HASH_VARIABLE_"))

    #set($lmTmSource = $functions.getListMap($lmSource.value,"triples_map_id"))

    #foreach($lmTmSourceEntry in $lmTmSource.entrySet())
        #* SUBJECT *#
        
        #set($tm = $lmTmSourceEntry.value.get(0))
        #set($subject = "#subjectRender($tm $hashVariable)")
        #set($subject = $subject.trim())

        #* GRAPH *#
        #set($graph = $null)
        #* TODO Check if only one graph can be defined for each triplemap *#
        #if($tm.graph_template)
            #set($graph = $functions.resolveTemplate($tm.graph_template))
        #elseif($tm.graph_reference)
            #set($graph = $functions.resolveReference($tm.graph_reference))
        #elseif($tm.graph_constant)
            #set($graph = $tm.graph_constant)
        #elseif($tm.graph_constant_shortcut)
            #set($graph = $tm.graph_constant_shortcut)
        #end
        #* rml:defaultGraph mapped to the default graph *#
        #if($graph == "http://w3id.org/rml/defaultGraph")
            #set($graph = $null)
        #else
            #set($graph = $functions.encodeReferencesIRI($graph, $hashVariable))
        #end
        
        #* Init template execution *#
        ${h}foreach(${d}i in ${d}dataframe_$sourceHash)

        #set($subjectClassesQuery = $subjectClassesQuery.replace("TRIPLES_MAP",$tm.triples_map_id))
        #set($subjectClasses = $reader.getDataframe($subjectClassesQuery))
        #foreach($subjClass in $subjectClasses)
            #if($graph)
                $subject <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <$subjClass.subject_rdf_class> <$graph>.
            #else
                $subject <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <$subjClass.subject_rdf_class> .
            #end
        #end

        #* PO MAPS *#
        #foreach($pom in $lmTmSourceEntry.value)

            #* PREDICATE *#
            #set($predicate = $null)
            #if($pom.predicate_template)
                #set($predicate = $functions.resolveTemplate($pom.predicate_template))
            #elseif($pom.predicate_reference)
                #set($predicate = $functions.resolveReference($pom.predicate_reference))
            #elseif($pom.predicate_constant)
                #set($predicate = $pom.predicate_constant)
            #elseif($pom.predicate_constant_shortcut)
                #set($predicate = $pom.predicate_constant_shortcut)
            #end
            #set($predicate = $functions.encodeReferencesIRI($predicate, $hashVariable))

            #* OBJECT *#
            #* TODO Gestire Language Tags and Data types *#
            #set($objects = [])
            #if($pom.object_template)
                #set($foo = $objects.add($functions.resolveTemplate($pom.object_template)))
            #elseif($pom.object_reference)
                #set($foo = $objects.add($functions.resolveReference($pom.object_reference)))
            #elseif($pom.object_constant)
                #set($foo = $objects.add($pom.object_constant))
            #elseif($pom.object_constant_shortcut)
                #set($foo = $objects.add($pom.object_constant_shortcut))
            #elseif($pom.object_parent_triples_map)
                #set($join_hash = $functions.appendHash($pom.triples_map_id, $pom.object_parent_triples_map, $pom.child_value, $pom.parent_value))
                #set($ptm = $lTriplesMaps.get($pom.object_parent_triples_map))

                #* TODO Define a MACRO to define it once *#
                #set($parent_subject = $null)
                #set($parent_subject = "#subjectRender($ptm $hashVariable)")
                #set($parent_subject = $parent_subject.trim())
                #set($foo = $objects.add("_REFERENCING_OBJECT_MAP_"))
            #end

            #foreach($object in $objects)
                #* 
                    TODO Improve condition using FILTER (isLiteral(?value)) in SPARQL Query
                    and checking the object_termtype OR implementing a $functions.isIRI($object)
                *#

                #if($object.equals("_REFERENCING_OBJECT_MAP_"))
                    #if($pom.child_value)
                        #set($join_variable = $pom.child_value)
                        #if($hashVariable)
                            #set($join_variable = $functions.hash($pom.child_value))
                        #end
                        ${h}if(${d}functions.checkString(${d}i.$join_variable))
                        ${h}foreach(${d}j in ${d}dataframe_join_${join_hash}.get(${d}i.$join_variable))
                    #else
                        #* No Join condition: iterate on the same dataframe *#
                        ${h}foreach(${d}j in ${d}dataframe_join_$join_hash)
                    #end  
                            #set($parent_subject = $parent_subject.replaceAll("\{i.","\{j."))

                            #set($refs = $functions.getReferencesFromTriple($subject, $predicate, $parent_subject, $graph))
                    
                            ${h}set(${d}refs = $refs)

                            #* Generate the triple/quad . *#
                            ${h}if(${d}functions.checkStrings(${d}refs))
                            #if($graph)
                                $subject <$predicate> $parent_subject <$graph>.
                            #else
                                $subject <$predicate> $parent_subject .
                            #end
                            ${h}end

                        ${h}end
                    #if($pom.child_value)
                        ${h}end
                    #end
                #else
                    #if($object.contains("://"))
                        #set($object = '<' + $functions.encodeReferencesIRI($object, $hashVariable) + '>')
                    #else
                        #set($raw_object = $object)
                        #set($object = '"' + $functions.encodeReferencesLiteral($object, $hashVariable) + '"')

                        #if($sqlTypes && $raw_object.startsWith('$'))
                            #set($column = $functions.getIteratorFromString($raw_object))
                            #set($object = $object + '#if($types_' + $sourceHash + ')#set($type = $types_' + $sourceHash + '.get("' + $column + '"))#set($rdfType = $functions.getXsdFromSqlDatatypes($type))#if($rdfType)^^<$rdfType>#end#end')
                        #end
                    #end

                    #set($refs = $functions.getReferencesFromTriple($subject, $predicate, $object, $graph))
                    
                    ${h}set(${d}refs = $refs)

                    #* Generate the triple/quad . *#
                    ${h}if(${d}functions.checkStrings(${d}refs))
                    #if($graph)
                        $subject <$predicate> $object <$graph>.
                    #else
                        $subject <$predicate> $object .
                    #end
                    ${h}end
                #end
            #end

        #end
        ${h}end
    #end

#end

#*
    
  #end

  #foreach($tm in $ltm_content.entrySet())
  #set($tm_id = $functions.hash($tm.key.toString()))
  #if ($tm.value.get(0).iterator_tech=="http://semweb.mmlab.be/ns/ql#XPath")
  tripleMaker_$tm_id
  #elseif ($tm.value.get(0).iterator_tech=="http://semweb.mmlab.be/ns/ql#JSONPath")
  tripleMaker_$tm_id
  #else
  tripleMaker_$tm_id
  #end

      http://www.w3.org/1999/02/22-rdf-syntax-ns#type
      
    #foreach($tmp in $tm.value)
        ## <!-- P-O $tmp -->
        #if($tmp.predicate_constant)
            $tmp.predicate_constant
        #elseif($tmp.predicate_template)
            $tmp.predicate_template
        #elseif($tmp.predicate_reference)
            ${pa}$tmp.predicate_reference${pc}
        #end
    #end
    
    #foreach($tmp in $tm.value)
        #if($tmp.subject_rdf_class)<value>$tmp.subject_rdf_class</value>#end
    #end      
    #foreach($tmp in $tm.value)
        #if($tmp.object_constant)$tmp.object_constant
        #elseif($tmp.object_template)$tmp.object_template
        #elseif($tmp.object_reference)${pa}$tmp.object_reference${pc}
        #end
    #end

    #foreach($tmp in $tm.value)
        #if($tmp.subject_rdf_class)
        http://www.w3.org/ns/r2rml#IRI
        #end
    #end
      
      #foreach($tmp in $tm.value)
        ## <!-- Object type $tmp -->
        #if($tmp.object_constant)
            #if($tmp.object_constant.toString().contains("://"))
            http://www.w3.org/ns/r2rml#IRI
            #else
                #if($tmp.object_language)
                http://www.w3.org/ns/r2rml#Literal@$tmp.object_language
                #else
                http://www.w3.org/ns/r2rml#Literal
                #end
            #end
        #elseif($tmp.object_reference)
                #if($tmp.object_language)
                http://www.w3.org/ns/r2rml#Literal@$tmp.object_language
                #else
                http://www.w3.org/ns/r2rml#Literal
                #end
        #else
            $tmp.object_termtype
        #end
      #end
  #end

#foreach($source in $sources)
#set ( $source_descr = $reader.executeQueryStringValue("SELECT DISTINCT ?data_format ?iterator
		WHERE {
            ?tm a rr:TriplesMap;
                rml:logicalSource [
                    rml:source ""$source.data_source"";
                    rml:referenceFormulation ?data_format;
                    rml:iterator ?iterator
                ].
        }
        GROUP BY ?iterator ?data_format
") )

*#